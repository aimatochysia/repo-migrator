name: Recommit Source Repo History to Target Repo

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: "Source repository (owner/name), e.g. octocat/hello-world"
        required: true
        type: string
      target_repo:
        description: "Target repository (owner/name), e.g. my-org/rewritten-history"
        required: true
        type: string
      author_name:
        description: "New author name for all commits, e.g. John Doe"
        required: true
        type: string
      author_email:
        description: "New author email for all commits, e.g. john.doe@example.com"
        required: true
        type: string

jobs:
  recommit:
    runs-on: ubuntu-latest
    env:
      PAT: ${{ secrets.PAT }}
    steps:
      - name: Validate PAT
        run: |
          if [ -z "$PAT" ]; then
            echo "PAT is not set" >&2
            exit 1
          fi

      - name: Clone source repository
        run: |
          set -e
          mkdir -p "$GITHUB_WORKSPACE/work"
          echo "Cloning source repo ${{ inputs.source_repo }}"
          git clone https://x-access-token:${PAT}@github.com/${{ inputs.source_repo }}.git \
            "$GITHUB_WORKSPACE/work/source"
          cd "$GITHUB_WORKSPACE/work/source"
          git checkout main

      - name: Prepare target repository
        run: |
          set -e
          echo "Cloning target repo ${{ inputs.target_repo }}"
          git clone https://x-access-token:${PAT}@github.com/${{ inputs.target_repo }}.git \
            "$GITHUB_WORKSPACE/work/target"
          cd "$GITHUB_WORKSPACE/work/target"
          
          echo "Cleaning target repository completely"
          # Create a fresh orphan branch (no history)
          git checkout --orphan temp-branch
          
          # Remove all files from git tracking
          git rm -rf . 2>/dev/null || true
          
          # Also remove any untracked files
          git clean -fdx
          
          # Rename temp branch to main (will delete old main if it exists)
          git branch -M temp-branch main
          
          echo "Adding source repo as remote"
          git remote add source "$GITHUB_WORKSPACE/work/source"
          git fetch source

      - name: Recommit history with author rewrite and Copilot squash
        run: |
          set -euo pipefail

          SRC_DIR="$GITHUB_WORKSPACE/work/source"
          TGT_DIR="$GITHUB_WORKSPACE/work/target"

          NEW_AUTHOR_NAME="${{ inputs.author_name }}"
          NEW_AUTHOR_EMAIL="${{ inputs.author_email }}"

          # Ensure committer identity is always set
          export GIT_COMMITTER_NAME="$NEW_AUTHOR_NAME"
          export GIT_COMMITTER_EMAIL="$NEW_AUTHOR_EMAIL"

          echo "Starting history rewrite"

          cd "$SRC_DIR"
          COMMITS=$(git rev-list --reverse main)

          cd "$TGT_DIR"

          # Arrays to track squashed Copilot commits
          SQUASH_TITLES=()
          SQUASH_BODIES=()
          CURRENT_SQUASH_DATE=""
          SQUASHING=false

          # Function to clean commit message (remove Co-authored-by lines)
          clean_commit_message() {
            local msg="$1"
            echo "$msg" | grep -v "^Co-authored-by:" | sed '/^$/N;/^\n$/D'
          }

          # Function to select random commit title (excluding merge/squash keywords)
          select_commit_title() {
            local titles=("$@")
            local valid_titles=()
            
            for title in "${titles[@]}"; do
              if ! echo "$title" | grep -qiE "(merge|squash)"; then
                valid_titles+=("$title")
              fi
            done
            
            if [ ${#valid_titles[@]} -eq 0 ]; then
              # If no valid titles, use a default
              echo "Update code"
              return
            fi
            
            # Select random title
            local idx=$((RANDOM % ${#valid_titles[@]}))
            echo "${valid_titles[$idx]}"
          }

          for COMMIT in $COMMITS; do
            cd "$SRC_DIR"
            AUTHOR_NAME=$(git show -s --format='%an' $COMMIT)
            AUTHOR_EMAIL=$(git show -s --format='%ae' $COMMIT)
            AUTHOR_DATE=$(git show -s --format='%aI' $COMMIT)
            COMMIT_MSG=$(git show -s --format='%B' $COMMIT)
            COMMIT_SUBJECT=$(git show -s --format='%s' $COMMIT)

            # Check if this is a merge commit (has more than one parent)
            PARENT_COUNT=$(git rev-list --parents -n 1 $COMMIT | awk '{print NF-1}')

            cd "$TGT_DIR"

            echo "Processing commit $COMMIT"
            echo "  Original author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
            echo "  Date: $AUTHOR_DATE"

            # Skip merge commits - their changes are already in the history via their parents
            if [ "$PARENT_COUNT" -gt 1 ]; then
              echo "  -> Skipping merge commit (changes already in history via parents)"
              continue
            fi

            IS_COPILOT=false
            if echo "$AUTHOR_NAME $AUTHOR_EMAIL" | grep -qi "copilot"; then
              IS_COPILOT=true
            fi

            if [ "$IS_COPILOT" = true ]; then
              echo "  -> Identified as Copilot commit, squashing"
              SQUASHING=true
              
              # Store commit title and cleaned body
              SQUASH_TITLES+=("$COMMIT_SUBJECT")
              CLEANED_MSG=$(clean_commit_message "$COMMIT_MSG")
              if [ -n "$CLEANED_MSG" ]; then
                SQUASH_BODIES+=("$CLEANED_MSG")
              fi
              
              if [ -z "$CURRENT_SQUASH_DATE" ]; then
                CURRENT_SQUASH_DATE="$AUTHOR_DATE"
              fi
              
              # Apply this Copilot commit's changes to working tree without committing
              echo "  -> Applying changes from $COMMIT to working tree"
              if ! git cherry-pick --no-commit "$COMMIT" >/dev/null 2>&1; then
                echo "  -> Cherry-pick had conflicts, resolving with theirs strategy"
                # Accept all changes from the commit being cherry-picked
                git checkout --theirs . 2>/dev/null || true
                git add -A
              fi
              continue
            fi

            if [ "$SQUASHING" = true ]; then
              echo "Committing squashed Copilot commits"
              git add -A || true
              
              # Select a random title from collected titles
              FINAL_TITLE=$(select_commit_title "${SQUASH_TITLES[@]}")
              
              # Combine bodies (if any)
              FINAL_BODY=""
              if [ ${#SQUASH_BODIES[@]} -gt 0 ]; then
                FINAL_BODY=$(printf "%s\n\n" "${SQUASH_BODIES[@]}")
              fi
              
              # Create commit with selected title and cleaned body
              FINAL_MSG="${FINAL_TITLE}"
              if [ -n "$FINAL_BODY" ]; then
                FINAL_MSG="${FINAL_TITLE}\n\n${FINAL_BODY}"
              fi
              
              GIT_AUTHOR_NAME="$NEW_AUTHOR_NAME" \
              GIT_AUTHOR_EMAIL="$NEW_AUTHOR_EMAIL" \
              GIT_AUTHOR_DATE="$CURRENT_SQUASH_DATE" \
              GIT_COMMITTER_DATE="$CURRENT_SQUASH_DATE" \
              git commit --allow-empty -m "$(echo -e "$FINAL_MSG")"

              # Reset squash tracking
              SQUASH_TITLES=()
              SQUASH_BODIES=()
              CURRENT_SQUASH_DATE=""
              SQUASHING=false
            fi

            echo "Cherry-picking commit $COMMIT"
            if ! git cherry-pick --no-commit "$COMMIT" >/dev/null 2>&1; then
              echo "  -> Cherry-pick had conflicts, resolving with theirs strategy"
              # Accept all changes from the commit being cherry-picked
              git checkout --theirs . 2>/dev/null || true
              git add -A
            fi

            git add -A
            
            # Clean the commit message before committing
            CLEANED_COMMIT_MSG=$(clean_commit_message "$COMMIT_MSG")
            
            GIT_AUTHOR_NAME="$NEW_AUTHOR_NAME" \
            GIT_AUTHOR_EMAIL="$NEW_AUTHOR_EMAIL" \
            GIT_AUTHOR_DATE="$AUTHOR_DATE" \
            GIT_COMMITTER_DATE="$AUTHOR_DATE" \
            git commit -m "$CLEANED_COMMIT_MSG"

            echo "  -> Commit created for $COMMIT"
          done

          if [ "$SQUASHING" = true ]; then
            echo "Finalizing trailing Copilot squash"
            git add -A || true
            
            # Select a random title from collected titles
            FINAL_TITLE=$(select_commit_title "${SQUASH_TITLES[@]}")
            
            # Combine bodies (if any)
            FINAL_BODY=""
            if [ ${#SQUASH_BODIES[@]} -gt 0 ]; then
              FINAL_BODY=$(printf "%s\n\n" "${SQUASH_BODIES[@]}")
            fi
            
            # Create commit with selected title and cleaned body
            FINAL_MSG="${FINAL_TITLE}"
            if [ -n "$FINAL_BODY" ]; then
              FINAL_MSG="${FINAL_TITLE}\n\n${FINAL_BODY}"
            fi
            
            GIT_AUTHOR_NAME="$NEW_AUTHOR_NAME" \
            GIT_AUTHOR_EMAIL="$NEW_AUTHOR_EMAIL" \
            GIT_AUTHOR_DATE="$CURRENT_SQUASH_DATE" \
            GIT_COMMITTER_DATE="$CURRENT_SQUASH_DATE" \
            git commit --allow-empty -m "$(echo -e "$FINAL_MSG")"
          fi

      - name: Push rewritten history to target
        run: |
          set -e
          cd "$GITHUB_WORKSPACE/work/target"
          echo "Pushing rewritten history to target repo"
          git branch -M main
          git push -f https://x-access-token:${PAT}@github.com/${{ inputs.target_repo }}.git main
          echo "Push completed"
